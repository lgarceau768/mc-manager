import { v4 as uuidv4 } from 'uuid';
import path from 'path';
import fs from 'fs';
import os from 'os';
import { fileURLToPath } from 'url';
import AdmZip from 'adm-zip';
import { PNG } from 'pngjs';
import Server from '../models/Server.js';
import dockerService from './dockerService.js';
import portService from './portService.js';
import logger from '../utils/logger.js';
import { getPreferredHost } from '../utils/network.js';
import { NotFoundError, ConflictError, ValidationError } from '../utils/errors.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

class ServerService {
  constructor() {
    this.serversDataPath = process.env.SERVERS_DATA_PATH || path.join(__dirname, '../../data/servers');
    this.modpacksBasePath = process.env.MODPACKS_PATH || path.join(__dirname, '../../modpacks');
    this.serversDataHostPath = process.env.SERVERS_DATA_PATH_HOST || this.serversDataPath;
    this.serverTypes = ['PAPER', 'FABRIC', 'FORGE'];

    // Ensure servers data directory exists
    if (!fs.existsSync(this.serversDataPath)) {
      fs.mkdirSync(this.serversDataPath, { recursive: true });
    }

    if (!fs.existsSync(this.modpacksBasePath)) {
      fs.mkdirSync(this.modpacksBasePath, { recursive: true });
    }

    this.serverTypes.forEach((type) => {
      const dir = this.getModpackDir(type);
      if (!fs.existsSync(dir)) {
        fs.mkdirSync(dir, { recursive: true });
      }
    });
  }

  /**
   * Create a new server
   */
  async createServer({ name, version, memory, cpuLimit, type, modpack }) {
    try {
      logger.info(`Creating server: ${name}`);

      const serverType = this.normalizeServerType(type || 'PAPER');

      // Check if server with this name already exists
      const existingServer = Server.findByName(name);
      if (existingServer) {
        throw new ConflictError(`Server with name "${name}" already exists`);
      }

      // Generate unique ID
      const serverId = uuidv4();

      // Get next available port
      const port = portService.getNextAvailablePort();

      // Create volume directory
      const volumePath = path.join(this.serversDataPath, serverId);
      const volumeHostPath = path.join(this.serversDataHostPath, serverId);
      if (!fs.existsSync(volumePath)) {
        fs.mkdirSync(volumePath, { recursive: true });
      }

      // Ensure Minecraft EULA is accepted for this server data directory
      this.ensureEulaAccepted(volumePath);

      if (modpack) {
        this.installSavedModpack(serverType, modpack, volumePath);
      }

      // Create Docker container
      const containerId = await dockerService.createContainer({
        serverId,
        name,
        version,
        port,
        memory,
        cpuLimit,
        volumePath,
        volumeHostPath,
        type: serverType
      });

      // Save server to database
      const server = Server.create({
        id: serverId,
        name,
        type: serverType,
        version,
        port,
        memory,
        cpuLimit,
        volumePath
      });

      // Update with container ID
      Server.update(serverId, { container_id: containerId });

      logger.info(`Server created successfully: ${serverId}`);
      const createdServer = Server.findById(serverId);
      return this.withConnectionInfo({
        ...createdServer,
        settings: this.getServerSettingsData(createdServer)
      });
    } catch (error) {
      logger.error(`Failed to create server: ${error.message}`);
      throw error;
    }
  }

  /**
   * Ensure the Minecraft EULA has been accepted for the given server data directory.
   * The itzg/minecraft-server image will also honor the EULA=TRUE env, but we create/update
   * the eula.txt proactively to mirror Mojang's required acknowledgement.
   */
  ensureEulaAccepted(volumePath) {
    try {
      const eulaPath = path.join(volumePath, 'eula.txt');
      if (fs.existsSync(eulaPath)) {
        const contents = fs.readFileSync(eulaPath, 'utf8');
        if (/^\s*eula\s*=\s*true\s*$/im.test(contents)) {
          return;
        }
      }

      const lines = [
        `# ${new Date().toISOString()} - Automatically generated by Minecraft Server Manager`,
        '# By setting the option below to TRUE you are indicating your agreement to the Minecraft EULA (https://aka.ms/MinecraftEULA).',
        'eula=true',
        ''
      ];
      fs.writeFileSync(eulaPath, lines.join('\n'), 'utf8');
      logger.info(`EULA accepted for server data at ${eulaPath}`);
    } catch (error) {
      logger.warn(`Unable to ensure EULA acceptance: ${error.message}`);
    }
  }

  /**
   * Start a server
   */
  async startServer(serverId) {
    try {
      logger.info(`Starting server: ${serverId}`);

      const server = Server.findById(serverId);
      if (!server) {
        throw new NotFoundError(`Server not found: ${serverId}`);
      }

      if (server.status === 'running') {
        throw new ConflictError('Server is already running');
      }

      // Update status to starting
      Server.update(serverId, { status: 'starting' });

      // Start container
      await dockerService.startContainer(server.container_id);

      // Poll until container is fully running
      await this.waitForServerReady(server.container_id);

      // Update status to running
      Server.update(serverId, { status: 'running' });

      logger.info(`Server started successfully: ${serverId}`);
      const updated = Server.findById(serverId);
      return this.withConnectionInfo({
        ...updated,
        settings: this.getServerSettingsData(updated)
      });
    } catch (error) {
      // Revert status on error
      Server.update(serverId, { status: 'stopped' });
      logger.error(`Failed to start server: ${error.message}`);
      throw error;
    }
  }

  /**
   * Stop a server
   */
  async stopServer(serverId) {
    try {
      logger.info(`Stopping server: ${serverId}`);

      const server = Server.findById(serverId);
      if (!server) {
        throw new NotFoundError(`Server not found: ${serverId}`);
      }

      if (server.status === 'stopped') {
        throw new ConflictError('Server is already stopped');
      }

      // Update status to stopping
      Server.update(serverId, { status: 'stopping' });

      // Stop container (gracefully with save-all)
      await dockerService.stopContainer(server.container_id);

      // Update status to stopped
      Server.update(serverId, { status: 'stopped' });

      logger.info(`Server stopped successfully: ${serverId}`);
      const updated = Server.findById(serverId);
      return this.withConnectionInfo({
        ...updated,
        settings: this.getServerSettingsData(updated)
      });
    } catch (error) {
      logger.error(`Failed to stop server: ${error.message}`);
      throw error;
    }
  }

  /**
   * Restart a server
   */
  async restartServer(serverId) {
    try {
      logger.info(`Restarting server: ${serverId}`);

      await this.stopServer(serverId);
      // Wait a bit before starting
      await new Promise(resolve => setTimeout(resolve, 2000));
      await this.startServer(serverId);

      logger.info(`Server restarted successfully: ${serverId}`);
      const updated = Server.findById(serverId);
      return this.withConnectionInfo({
        ...updated,
        settings: this.getServerSettingsData(updated)
      });
    } catch (error) {
      logger.error(`Failed to restart server: ${error.message}`);
      throw error;
    }
  }

  /**
   * Delete a server
   */
  async deleteServer(serverId) {
    try {
      logger.info(`Deleting server: ${serverId}`);

      const server = Server.findById(serverId);
      if (!server) {
        throw new NotFoundError(`Server not found: ${serverId}`);
      }

      // Stop server if running
      if (server.status === 'running') {
        await this.stopServer(serverId);
      }

      // Remove Docker container
      if (server.container_id) {
        await dockerService.removeContainer(server.container_id);
      }

      // Delete from database
      Server.delete(serverId);

      // Optionally archive or delete volume
      // For now, we'll leave the volume in place for data recovery
      logger.info(`Server deleted successfully (volume preserved): ${serverId}`);

      return { message: 'Server deleted successfully' };
    } catch (error) {
      logger.error(`Failed to delete server: ${error.message}`);
      throw error;
    }
  }

  /**
   * Get server details with runtime stats
   */
  async getServerDetails(serverId) {
    try {
      const server = Server.findById(serverId);
      if (!server) {
        throw new NotFoundError(`Server not found: ${serverId}`);
      }
      const settings = this.getServerSettingsData(server);

      // If running, fetch stats
      if (server.status === 'running' && server.container_id) {
        try {
          const stats = await dockerService.getContainerStats(server.container_id);
          return this.withConnectionInfo({ ...server, stats, settings });
        } catch (error) {
          logger.warn(`Failed to get stats for server ${serverId}: ${error.message}`);
          return this.withConnectionInfo({ ...server, settings });
        }
      }

      return this.withConnectionInfo({ ...server, settings });
    } catch (error) {
      logger.error(`Failed to get server details: ${error.message}`);
      throw error;
    }
  }

  /**
   * List all servers with optional stats
   */
  async listServers() {
    try {
      const servers = Server.findAll();

      // Fetch stats for running servers
      const serversWithStats = await Promise.all(
        servers.map(async (server) => {
          if (server.status === 'running' && server.container_id) {
            try {
              const stats = await dockerService.getContainerStats(server.container_id);
              return this.withConnectionInfo({ ...server, stats });
            } catch (error) {
              logger.warn(`Failed to get stats for server ${server.id}: ${error.message}`);
              return this.withConnectionInfo(server);
            }
          }
          return this.withConnectionInfo(server);
        })
      );

      return serversWithStats;
    } catch (error) {
      logger.error(`Failed to list servers: ${error.message}`);
      throw error;
    }
  }

  /**
   * Get server logs
   */
  async getServerLogs(serverId, tail = 100) {
    try {
      const server = Server.findById(serverId);
      if (!server) {
        throw new NotFoundError(`Server not found: ${serverId}`);
      }

      if (!server.container_id) {
        throw new ValidationError('Server has no container');
      }

      const logs = await dockerService.getContainerLogs(server.container_id, tail);
      return logs;
    } catch (error) {
      logger.error(`Failed to get server logs: ${error.message}`);
      throw error;
    }
  }

  /**
   * Handle mod/plugin upload or server pack import
   */
  async uploadModOrPack(serverId, file) {
    const server = Server.findById(serverId);
    if (!server) {
      throw new NotFoundError(`Server not found: ${serverId}`);
    }

    if (!file || !file.path) {
      throw new ValidationError('File upload is required');
    }

    const extension = path.extname(file.originalname || '').toLowerCase();
    const volumePath = server.volume_path;

    try {
      if (extension === '.zip') {
        const details = this.installPackArchive(file.path, volumePath);
        logger.info(`Installed server pack for ${serverId}`);
        return {
          type: 'pack',
          message: 'Server pack imported successfully',
          targetPath: volumePath,
          details
        };
      }

      if (extension === '.jar') {
        const targetFolder = server.type === 'PAPER' ? 'plugins' : 'mods';
        const targetDir = path.join(volumePath, targetFolder);
        fs.mkdirSync(targetDir, { recursive: true });

        const safeName = this.sanitizeFileName(file.originalname);
        const destination = path.join(targetDir, safeName);
        fs.copyFileSync(file.path, destination);
        logger.info(`Uploaded ${safeName} for server ${serverId} to ${targetFolder}`);

        return {
          type: 'mod',
          message: `Uploaded ${safeName} to ${targetFolder}`,
          targetPath: destination
        };
      }

      throw new ValidationError('Only .jar mods or .zip server packs are supported');
    } catch (error) {
      logger.error(`Failed to process upload for server ${serverId}: ${error.message}`);
      throw error;
    } finally {
      fs.unlink(file.path, () => {});
    }
  }

  /**
   * Update server.properties values
   */
  async updateServerSettings(serverId, settings) {
    const server = Server.findById(serverId);
    if (!server) {
      throw new NotFoundError(`Server not found: ${serverId}`);
    }

    const { props, propsPath } = this.getServerProperties(server.volume_path);
    const propertyMap = {
      motd: 'motd',
      maxPlayers: 'max-players',
      difficulty: 'difficulty',
      pvp: 'pvp',
      whitelist: 'white-list',
      allowNether: 'allow-nether',
      hardcore: 'hardcore',
      viewDistance: 'view-distance'
    };

    let changed = false;

    for (const [key, propertyKey] of Object.entries(propertyMap)) {
      if (settings[key] === undefined) continue;
      let value = settings[key];

      switch (key) {
        case 'motd':
          value = this.escapeMotd(value);
          break;
        case 'maxPlayers':
          value = parseInt(value, 10);
          if (Number.isNaN(value)) continue;
          break;
        case 'viewDistance':
          value = parseInt(value, 10);
          if (Number.isNaN(value)) continue;
          break;
        case 'pvp':
        case 'whitelist':
        case 'allowNether':
        case 'hardcore':
          value = value ? 'true' : 'false';
          break;
        case 'difficulty':
          value = String(value).toLowerCase();
          break;
        default:
          value = String(value);
      }

      props[propertyKey] = value;
      changed = true;
    }

    if (!changed) {
      return this.withConnectionInfo({
        ...server,
        settings: this.getServerSettingsData(server)
      });
    }

    this.writeServerProperties(propsPath, props);
    const updatedSettings = this.getServerSettingsData(server);
    return this.withConnectionInfo({
      ...server,
      settings: updatedSettings
    });
  }

  /**
   * Update server icon (server-icon.png)
   */
  async updateServerIcon(serverId, file) {
    const server = Server.findById(serverId);
    if (!server) {
      throw new NotFoundError(`Server not found: ${serverId}`);
    }

    if (!file || !file.path) {
      throw new ValidationError('Icon file is required');
    }

    try {
      const ext = path.extname(file.originalname || '').toLowerCase();
      if (ext !== '.png') {
        throw new ValidationError('Server icon must be a .png file');
      }

      const buffer = fs.readFileSync(file.path);
      let image;
      try {
        image = PNG.sync.read(buffer);
      } catch (error) {
        throw new ValidationError('Invalid PNG file');
      }

      if (image.width !== 64 || image.height !== 64) {
        throw new ValidationError('Server icon must be 64x64 pixels');
      }

      const iconPath = this.getServerIconFilePath(server.volume_path);
      fs.writeFileSync(iconPath, buffer);

      logger.info(`Updated server icon for ${serverId}`);
      return { message: 'Server icon updated successfully' };
    } finally {
      fs.unlink(file.path, () => {});
    }
  }

  /**
   * Get absolute path to server icon (if exists)
   */
  getServerIconPath(serverId) {
    const server = Server.findById(serverId);
    if (!server) {
      throw new NotFoundError(`Server not found: ${serverId}`);
    }

    const iconPath = this.getServerIconFilePath(server.volume_path);
    if (!fs.existsSync(iconPath)) {
      return null;
    }
    return iconPath;
  }

  sanitizeFileName(filename = '') {
    return filename.replace(/[^a-zA-Z0-9._-]/g, '_');
  }

  withConnectionInfo(server) {
    if (!server) return server;
    const host = getPreferredHost();
    const address = host ? `${host}:${server.port}` : `localhost:${server.port}`;

    return {
      ...server,
      connectionInfo: {
        host: host || 'localhost',
        port: server.port,
        address
      }
    };
  }

  /**
   * Wait for server to be ready
   */
  async waitForServerReady(containerId, maxAttempts = 60) {
    for (let i = 0; i < maxAttempts; i++) {
      const isRunning = await dockerService.isContainerRunning(containerId);

      if (isRunning) {
        // Wait a bit more to ensure the server is fully initialized
        await new Promise(resolve => setTimeout(resolve, 2000));
        return true;
      }

      await new Promise(resolve => setTimeout(resolve, 1000));
    }

    throw new Error('Server failed to start within timeout');
  }

  getServerProperties(volumePath) {
    const propsPath = path.join(volumePath, 'server.properties');
    const props = {};

    if (fs.existsSync(propsPath)) {
      const content = fs.readFileSync(propsPath, 'utf8');
      content.split(/\r?\n/).forEach(line => {
        if (!line || line.startsWith('#')) return;
        const idx = line.indexOf('=');
        if (idx === -1) return;
        const key = line.slice(0, idx).trim();
        const value = line.slice(idx + 1).trim();
        if (key) props[key] = value;
      });
    }

    return { props, propsPath };
  }

  writeServerProperties(propsPath, props) {
    fs.mkdirSync(path.dirname(propsPath), { recursive: true });
    const lines = [
      '# Minecraft server properties',
      `# Updated ${new Date().toISOString()}`
    ];

    Object.keys(props)
      .sort()
      .forEach((key) => {
        lines.push(`${key}=${props[key]}`);
      });

    fs.writeFileSync(propsPath, `${lines.join('\n')}\n`, 'utf8');
  }

  getServerSettingsData(server) {
    if (!server) return {};
    const { props } = this.getServerProperties(server.volume_path);

    const parseBool = (value, fallback = false) => {
      if (value === undefined) return fallback;
      return String(value).toLowerCase() === 'true';
    };

    const toInt = (value, fallback) => {
      if (value === undefined) return fallback;
      const num = parseInt(value, 10);
      return Number.isNaN(num) ? fallback : num;
    };

    return {
      motd: this.unescapeMotd(props['motd'] || ''),
      maxPlayers: toInt(props['max-players'], 20),
      difficulty: props['difficulty'] || 'easy',
      pvp: parseBool(props['pvp'], true),
      whitelist: parseBool(props['white-list'], false),
      allowNether: parseBool(props['allow-nether'], true),
      hardcore: parseBool(props['hardcore'], false),
      viewDistance: toInt(props['view-distance'], 10)
    };
  }

  getServerIconFilePath(volumePath) {
    return path.join(volumePath, 'server-icon.png');
  }

  escapeMotd(value = '') {
    return String(value).replace(/\r?\n/g, '\\n');
  }

  unescapeMotd(value = '') {
    return value.replace(/\\n/g, '\n');
  }

  /**
   * List files within server's volume
   */
  async listServerFiles(serverId, targetPath = '') {
    const server = Server.findById(serverId);
    if (!server) {
      throw new NotFoundError(`Server not found: ${serverId}`);
    }

    const resolved = this.resolveServerPath(server.volume_path, targetPath);
    if (!fs.existsSync(resolved)) {
      throw new NotFoundError('Path does not exist');
    }

    const stats = fs.statSync(resolved);
    if (!stats.isDirectory()) {
      throw new ValidationError('Path must be a directory');
    }

    const entries = fs.readdirSync(resolved, { withFileTypes: true })
      .map((dirent) => {
        const fullPath = path.join(resolved, dirent.name);
        const stat = fs.statSync(fullPath);
        return {
          name: dirent.name,
          type: dirent.isDirectory() ? 'directory' : 'file',
          size: dirent.isDirectory() ? null : stat.size,
          modified: stat.mtimeMs,
          path: path.relative(server.volume_path, fullPath)
        };
      })
      .sort((a, b) => {
        if (a.type === b.type) {
          return a.name.localeCompare(b.name);
        }
        return a.type === 'directory' ? -1 : 1;
      });

    const relativePath = path.relative(server.volume_path, resolved);

    return {
      path: relativePath || '',
      entries
    };
  }

  /**
   * Upload arbitrary file to server volume
   */
  async uploadServerFile(serverId, destPath, file) {
    const server = Server.findById(serverId);
    if (!server) {
      throw new NotFoundError(`Server not found: ${serverId}`);
    }

    if (!file || !file.path) {
      throw new ValidationError('File upload is required');
    }

    const destinationDir = this.resolveServerPath(server.volume_path, destPath || '');

    const stats = fs.existsSync(destinationDir) ? fs.statSync(destinationDir) : null;
    if (stats && !stats.isDirectory()) {
      throw new ValidationError('Destination path must be a directory');
    }

    fs.mkdirSync(destinationDir, { recursive: true });
    const safeName = this.sanitizeFileName(file.originalname);
    const destination = path.join(destinationDir, safeName);

    fs.copyFileSync(file.path, destination);
    fs.unlink(file.path, () => {});

    logger.info(`Uploaded file ${safeName} for server ${serverId}`);
    return {
      message: 'File uploaded successfully',
      path: path.relative(server.volume_path, destination)
    };
  }

  getFileDownloadPath(serverId, targetPath = '') {
    const server = Server.findById(serverId);
    if (!server) {
      throw new NotFoundError(`Server not found: ${serverId}`);
    }

    const resolved = this.resolveServerPath(server.volume_path, targetPath);
    if (!fs.existsSync(resolved)) {
      throw new NotFoundError('File not found');
    }

    const stat = fs.statSync(resolved);
    if (!stat.isFile()) {
      throw new ValidationError('Only files can be downloaded');
    }

    return {
      absolutePath: resolved,
      filename: path.basename(resolved)
    };
  }

  resolveServerPath(volumePath, targetPath = '') {
    const normalized = path.normalize(targetPath || '');
    const joined = path.normalize(path.join(volumePath, normalized));
    if (!joined.startsWith(volumePath)) {
      throw new ValidationError('Path traversal is not allowed');
    }
    return joined;
  }

  normalizeServerType(type) {
    const normalized = String(type || 'PAPER').toUpperCase();
    if (!this.serverTypes.includes(normalized)) {
      throw new ValidationError(`Unsupported server type: ${type}`);
    }
    return normalized;
  }

  getModpackDir(type) {
    const normalized = this.normalizeServerType(type);
    return path.join(this.modpacksBasePath, normalized.toLowerCase());
  }

  listSavedModpacks(type) {
    const dir = this.getModpackDir(type);
    if (!fs.existsSync(dir)) return [];
    return fs.readdirSync(dir)
      .filter((name) => name.toLowerCase().endsWith('.zip'))
      .map((filename) => ({
        name: path.basename(filename, path.extname(filename)),
        filename
      }));
  }

  saveModpackFile(type, file) {
    const dir = this.getModpackDir(type);
    const ext = path.extname(file.originalname || '').toLowerCase();
    if (ext !== '.zip') {
      throw new ValidationError('Only .zip modpack files are supported');
    }
    const safeName = this.sanitizeFileName(file.originalname);
    const destination = path.join(dir, safeName);
    fs.copyFileSync(file.path, destination);
    return {
      name: path.basename(safeName, path.extname(safeName)),
      filename: safeName
    };
  }

  getSavedModpackZip(type, filename) {
    if (!filename) {
      throw new ValidationError('Modpack selection is required');
    }
    const dir = this.getModpackDir(type);
    const safeName = this.sanitizeFileName(filename);
    const fullPath = path.join(dir, safeName);
    if (!fs.existsSync(fullPath)) {
      throw new NotFoundError(`Modpack not found: ${filename}`);
    }
    return fullPath;
  }

  installSavedModpack(type, filename, volumePath) {
    const zipPath = this.getSavedModpackZip(type, filename);
    return this.installPackArchive(zipPath, volumePath);
  }

  installPackArchive(zipPath, volumePath) {
    const tempDir = fs.mkdtempSync(path.join(os.tmpdir(), 'mc-pack-'));
    try {
      const zip = new AdmZip(zipPath);
      zip.extractAllTo(tempDir, true);
      const packRoot = this.detectPackRoot(tempDir);
      return this.installPackFromDirectory(packRoot, volumePath);
    } finally {
      fs.rmSync(tempDir, { recursive: true, force: true });
    }
  }

  detectPackRoot(extractedDir) {
    const entries = fs.readdirSync(extractedDir).filter((name) => name !== '__MACOSX');
    if (entries.length === 1) {
      const single = path.join(extractedDir, entries[0]);
      if (fs.statSync(single).isDirectory()) {
        return single;
      }
    }
    return extractedDir;
  }

  installPackFromDirectory(packRoot, volumePath) {
    const summary = [];
    const directories = [
      'config',
      'mods',
      'libraries',
      'versions',
      'kubejs',
      'scripts',
      'defaultconfigs',
      'resources',
      'shaderpacks'
    ];

    directories.forEach((dirName) => {
      const source = path.join(packRoot, dirName);
      if (fs.existsSync(source) && fs.statSync(source).isDirectory()) {
        const destination = path.join(volumePath, dirName);
        fs.rmSync(destination, { recursive: true, force: true });
        fs.mkdirSync(path.dirname(destination), { recursive: true });
        fs.cpSync(source, destination, { recursive: true });
        summary.push(`Copied ${dirName}/`);
      }
    });

    const rootEntries = fs.readdirSync(packRoot);
    rootEntries.forEach((name) => {
      const source = path.join(packRoot, name);
      const stat = fs.statSync(source);
      if (stat.isFile()) {
        const destination = path.join(volumePath, name);
        fs.copyFileSync(source, destination);
        summary.push(`Placed ${name}`);
      }
    });

    return summary;
  }
}

// Export singleton instance
export default new ServerService();
