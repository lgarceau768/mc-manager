import axios from 'axios';
import crypto from 'crypto';
import { v4 as uuidv4 } from 'uuid';
import path from 'path';
import fs from 'fs';
import os from 'os';
import { fileURLToPath } from 'url';
import AdmZip from 'adm-zip';
import { PNG } from 'pngjs';
import Server from '../models/Server.js';
import dockerService from './dockerService.js';
import portService from './portService.js';
import modpackImportService from './modpackImportService.js';
import logger from '../utils/logger.js';
import { getPreferredHost } from '../utils/network.js';
import { NotFoundError, ConflictError, ValidationError } from '../utils/errors.js';
import notificationService from './notificationService.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

class ServerService {
  constructor() {
    this.serversDataPath = process.env.SERVERS_DATA_PATH || path.join(__dirname, '../../../data/servers');
    this.modpacksBasePath = process.env.MODPACKS_PATH || path.join(__dirname, '../../../data/modpacks');
    this.serversDataHostPath = process.env.SERVERS_DATA_PATH_HOST || this.serversDataPath;
    this.backupsBasePath = process.env.BACKUPS_PATH || path.join(__dirname, '../../../data/backups');
    this.serverTypes = ['PAPER', 'FABRIC', 'FORGE', 'NEOFORGE'];

    // Ensure servers data directory exists
    if (!fs.existsSync(this.serversDataPath)) {
      fs.mkdirSync(this.serversDataPath, { recursive: true });
    }

    [this.modpacksBasePath, this.backupsBasePath].forEach((dir) => {
      if (!fs.existsSync(dir)) {
        fs.mkdirSync(dir, { recursive: true });
      }
    });

    this.serverTypes.forEach((type) => {
      const dir = this.getModpackDir(type);
      if (!fs.existsSync(dir)) {
        fs.mkdirSync(dir, { recursive: true });
      }
    });
  }

  /**
   * Create a new server
   */
  async createServer({ name, version, memory, cpuLimit, type, modpack, port: requestedPort }) {
    try {
      logger.info(`Creating server: ${name}`);

      const serverType = this.normalizeServerType(type || 'PAPER');

      // Check if server with this name already exists
      const existingServer = Server.findByName(name);
      if (existingServer) {
        throw new ConflictError(`Server with name "${name}" already exists`);
      }

      // Generate unique ID
      const serverId = uuidv4();

      // Determine port (requested or next available)
      let port;
      if (typeof requestedPort === 'number' && !Number.isNaN(requestedPort)) {
        try {
          portService.validatePort(requestedPort);
        } catch (error) {
          if (error instanceof ConflictError) {
            throw error;
          }
          throw new ValidationError(error.message);
        }
        port = requestedPort;
      } else {
        port = portService.getNextAvailablePort();
      }

      // Create volume directory
      const volumePath = path.join(this.serversDataPath, serverId);
      const volumeHostPath = path.join(this.serversDataHostPath, serverId);
      if (!fs.existsSync(volumePath)) {
        fs.mkdirSync(volumePath, { recursive: true });
      }

      // Ensure Minecraft EULA is accepted for this server data directory
      this.ensureEulaAccepted(volumePath);

      if (modpack) {
        await this.installSavedModpack(serverType, modpack, volumePath);
      }

      // Create Docker container
      const containerId = await dockerService.createContainer({
        serverId,
        name,
        version,
        port,
        memory,
        cpuLimit,
        volumePath,
        volumeHostPath,
        type: serverType
      });

      // Save server to database
      const server = Server.create({
        id: serverId,
        name,
        type: serverType,
        version,
        port,
        memory,
        cpuLimit,
        volumePath
      });

      // Update with container ID
      Server.update(serverId, { container_id: containerId });

      logger.info(`Server created successfully: ${serverId}`);
      const createdServer = Server.findById(serverId);
      return await this.withConnectionInfo({
        ...createdServer,
        settings: this.getServerSettingsData(createdServer)
      });
    } catch (error) {
      logger.error(`Failed to create server: ${error.message}`);
      throw error;
    }
  }

  /**
   * Ensure the Minecraft EULA has been accepted for the given server data directory.
   * The itzg/minecraft-server image will also honor the EULA=TRUE env, but we create/update
   * the eula.txt proactively to mirror Mojang's required acknowledgement.
   */
  ensureEulaAccepted(volumePath) {
    try {
      const eulaPath = path.join(volumePath, 'eula.txt');
      if (fs.existsSync(eulaPath)) {
        const contents = fs.readFileSync(eulaPath, 'utf8');
        if (/^\s*eula\s*=\s*true\s*$/im.test(contents)) {
          return;
        }
      }

      const lines = [
        `# ${new Date().toISOString()} - Automatically generated by Minecraft Server Manager`,
        '# By setting the option below to TRUE you are indicating your agreement to the Minecraft EULA (https://aka.ms/MinecraftEULA).',
        'eula=true',
        ''
      ];
      fs.writeFileSync(eulaPath, lines.join('\n'), 'utf8');
      logger.info(`EULA accepted for server data at ${eulaPath}`);
    } catch (error) {
      logger.warn(`Unable to ensure EULA acceptance: ${error.message}`);
    }
  }

  /**
   * Start a server
   */
  async startServer(serverId) {
    let server;
    try {
      logger.info(`Starting server: ${serverId}`);

      server = Server.findById(serverId);
      if (!server) {
        throw new NotFoundError(`Server not found: ${serverId}`);
      }

      if (server.status === 'running') {
        throw new ConflictError('Server is already running');
      }

      // Update status to starting
      Server.update(serverId, { status: 'starting' });

      // Start container
      await dockerService.startContainer(server.container_id);

      // Poll until container is fully running
      await this.waitForServerReady(server.container_id);

      // Update status to running
      Server.update(serverId, { status: 'running' });

      logger.info(`Server started successfully: ${serverId}`);

      // Send notification
      notificationService.notify(serverId, 'serverStart', {
        serverName: server.name
      }).catch(err => logger.warn(`Failed to send start notification: ${err.message}`));

      const updated = Server.findById(serverId);
      return await this.withConnectionInfo({
        ...updated,
        settings: this.getServerSettingsData(updated)
      });
    } catch (error) {
      // Revert status on error
      Server.update(serverId, { status: 'error' });
      logger.error(`Failed to start server: ${error.message}`);

      // Send error notification if we have server info
      if (server) {
        notificationService.notify(serverId, 'serverError', {
          serverName: server.name,
          error: error.message
        }).catch(err => logger.warn(`Failed to send error notification: ${err.message}`));
      }

      throw error;
    }
  }

  /**
   * Stop a server
   */
  async stopServer(serverId) {
    try {
      logger.info(`Stopping server: ${serverId}`);

      const server = Server.findById(serverId);
      if (!server) {
        throw new NotFoundError(`Server not found: ${serverId}`);
      }

      if (server.status === 'stopped') {
        throw new ConflictError('Server is already stopped');
      }

      // Update status to stopping
      Server.update(serverId, { status: 'stopping' });

      // Stop container (gracefully with save-all)
      await dockerService.stopContainer(server.container_id);

      // Update status to stopped
      Server.update(serverId, { status: 'stopped' });

      logger.info(`Server stopped successfully: ${serverId}`);

      // Send notification
      notificationService.notify(serverId, 'serverStop', {
        serverName: server.name
      }).catch(err => logger.warn(`Failed to send stop notification: ${err.message}`));

      const updated = Server.findById(serverId);
      return await this.withConnectionInfo({
        ...updated,
        settings: this.getServerSettingsData(updated)
      });
    } catch (error) {
      logger.error(`Failed to stop server: ${error.message}`);
      throw error;
    }
  }

  /**
   * Restart a server
   */
  async restartServer(serverId) {
    try {
      logger.info(`Restarting server: ${serverId}`);

      await this.stopServer(serverId);
      // Wait a bit before starting
      await new Promise(resolve => setTimeout(resolve, 2000));
      await this.startServer(serverId);

      logger.info(`Server restarted successfully: ${serverId}`);
      const updated = Server.findById(serverId);
      return await this.withConnectionInfo({
        ...updated,
        settings: this.getServerSettingsData(updated)
      });
    } catch (error) {
      logger.error(`Failed to restart server: ${error.message}`);
      throw error;
    }
  }

  /**
   * Recreate the Docker container for a server
   * Used when the container is removed/disconnected outside the application
   */
  async recreateContainer(serverId) {
    try {
      logger.info(`Recreating container for server: ${serverId}`);

      const server = Server.findById(serverId);
      if (!server) {
        throw new NotFoundError(`Server not found: ${serverId}`);
      }

      // Check if container already exists and is valid
      if (server.container_id) {
        try {
          const status = await dockerService.getContainerStatus(server.container_id);
          if (status.status !== 'stopped' || status.running) {
            throw new ConflictError('Container still exists. Stop and remove it first, or use restart instead.');
          }
        } catch (error) {
          // Container doesn't exist or can't be inspected - this is expected
          if (error.statusCode !== 404 && !(error instanceof ConflictError)) {
            logger.debug(`Container ${server.container_id} not found, will recreate`);
          } else if (error instanceof ConflictError) {
            throw error;
          }
        }
      }

      // Ensure the volume path exists
      const volumePath = server.volume_path;
      const volumeHostPath = path.join(this.serversDataHostPath, server.id);

      if (!fs.existsSync(volumePath)) {
        fs.mkdirSync(volumePath, { recursive: true });
        logger.info(`Created volume directory: ${volumePath}`);
      }

      // Ensure EULA is accepted
      this.ensureEulaAccepted(volumePath);

      // Create new container with stored settings
      const containerId = await dockerService.createContainer({
        serverId: server.id,
        name: server.name,
        version: server.version,
        port: server.port,
        memory: server.memory,
        cpuLimit: server.cpu_limit,
        volumePath,
        volumeHostPath,
        type: server.type
      });

      // Update database with new container ID
      Server.update(serverId, {
        container_id: containerId,
        status: 'stopped'
      });

      logger.info(`Container recreated successfully for server ${serverId}: ${containerId}`);

      const updatedServer = Server.findById(serverId);
      return await this.withConnectionInfo({
        ...updatedServer,
        settings: this.getServerSettingsData(updatedServer),
        containerRecreated: true
      });
    } catch (error) {
      logger.error(`Failed to recreate container: ${error.message}`);
      throw error;
    }
  }

  /**
   * Check if a server's container exists
   */
  async checkContainerExists(serverId) {
    const server = Server.findById(serverId);
    if (!server) {
      throw new NotFoundError(`Server not found: ${serverId}`);
    }

    if (!server.container_id) {
      return { exists: false, reason: 'no_container_id' };
    }

    try {
      await dockerService.getContainerStatus(server.container_id);
      return { exists: true };
    } catch (error) {
      if (error.statusCode === 404) {
        return { exists: false, reason: 'container_not_found' };
      }
      return { exists: false, reason: 'error', error: error.message };
    }
  }

  /**
   * Delete a server
   */
  async deleteServer(serverId) {
    try {
      logger.info(`Deleting server: ${serverId}`);

      const server = Server.findById(serverId);
      if (!server) {
        throw new NotFoundError(`Server not found: ${serverId}`);
      }

      // Stop server if running
      if (server.status === 'running') {
        await this.stopServer(serverId);
      }

      // Remove Docker container
      if (server.container_id) {
        await dockerService.removeContainer(server.container_id);
      }

      // Delete from database
      Server.delete(serverId);

      // Remove server volume and related files
      this.removeServerData(serverId, server.volume_path);

      return { message: 'Server deleted successfully' };
    } catch (error) {
      logger.error(`Failed to delete server: ${error.message}`);
      throw error;
    }
  }

  /**
   * Get server details with runtime stats
   */
  async getServerDetails(serverId) {
    try {
      const server = Server.findById(serverId);
      if (!server) {
        throw new NotFoundError(`Server not found: ${serverId}`);
      }
      const settings = this.getServerSettingsData(server);

      // Get detailed container status if container exists
      let containerStatus = null;
      let stats = null;

      if (server.container_id) {
        try {
          containerStatus = await dockerService.getContainerStatus(server.container_id);

          // Sync database status with actual container status if needed
          if (containerStatus.status === 'error' && server.status !== 'error') {
            Server.update(serverId, { status: 'error' });
          } else if (containerStatus.running && server.status === 'stopped') {
            Server.update(serverId, { status: 'running' });
          } else if (!containerStatus.running && server.status === 'running') {
            Server.update(serverId, { status: 'stopped' });
          }

          // Get stats if container is running
          if (containerStatus.running) {
            try {
              stats = await dockerService.getContainerStats(server.container_id);
            } catch (statsError) {
              logger.warn(`Failed to get stats for server ${serverId}: ${statsError.message}`);
            }
          }
        } catch (error) {
          logger.warn(`Failed to get container status for server ${serverId}: ${error.message}`);
        }
      }

      const updatedServer = Server.findById(serverId);
      return await this.withConnectionInfo({
        ...updatedServer,
        stats,
        settings,
        containerStatus
      });
    } catch (error) {
      logger.error(`Failed to get server details: ${error.message}`);
      throw error;
    }
  }

  /**
   * List all servers with optional stats
   */
  async listServers() {
    try {
      const servers = Server.findAll();

      // Fetch stats and container status for all servers
      const serversWithStats = await Promise.all(
        servers.map(async (server) => {
          let containerStatus = null;
          let stats = null;

          if (server.container_id) {
            try {
              containerStatus = await dockerService.getContainerStatus(server.container_id);

              // Sync database status with actual container status if needed
              if (containerStatus.status === 'error' && server.status !== 'error') {
                Server.update(server.id, { status: 'error' });
                server.status = 'error';
              } else if (containerStatus.running && server.status === 'stopped') {
                Server.update(server.id, { status: 'running' });
                server.status = 'running';
              } else if (!containerStatus.running && server.status === 'running') {
                Server.update(server.id, { status: 'stopped' });
                server.status = 'stopped';
              }

              // Get stats if container is running
              if (containerStatus.running) {
                try {
                  stats = await dockerService.getContainerStats(server.container_id);
                } catch (statsError) {
                  logger.warn(`Failed to get stats for server ${server.id}: ${statsError.message}`);
                }
              }
            } catch (error) {
              logger.warn(`Failed to get container status for server ${server.id}: ${error.message}`);
            }
          }

          return await this.withConnectionInfo({ ...server, stats, containerStatus });
        })
      );

      return serversWithStats;
    } catch (error) {
      logger.error(`Failed to list servers: ${error.message}`);
      throw error;
    }
  }

  removeServerData(serverId, volumePath) {
    const allowedRoots = [
      this.serversDataPath,
      this.serversDataHostPath,
      this.backupsBasePath
    ]
      .filter(Boolean)
      .map((p) => path.resolve(p));

    const hostVolumePath = this.serversDataHostPath
      ? path.join(this.serversDataHostPath, serverId)
      : null;
    const targets = [
      { targetPath: volumePath, label: 'server volume' },
      { targetPath: hostVolumePath, label: 'host server volume' },
      { targetPath: path.join(this.backupsBasePath, serverId), label: 'server backups' }
    ];

    targets.forEach(({ targetPath, label }) => {
      this.removeDirectoryIfSafe(targetPath, allowedRoots, label);
    });
  }

  removeDirectoryIfSafe(targetPath, allowedRoots, label) {
    if (!targetPath) return;
    const resolvedTarget = path.resolve(targetPath);
    if (!fs.existsSync(resolvedTarget)) {
      return;
    }

    const isAllowed = allowedRoots.some((root) =>
      resolvedTarget === root || resolvedTarget.startsWith(`${root}${path.sep}`)
    );

    if (!isAllowed) {
      logger.warn(`Refusing to delete ${label} outside managed directories: ${resolvedTarget}`);
      return;
    }

    try {
      fs.rmSync(resolvedTarget, { recursive: true, force: true });
      logger.info(`Deleted ${label} at ${resolvedTarget}`);
    } catch (error) {
      logger.warn(`Failed to delete ${label} at ${resolvedTarget}: ${error.message}`);
    }
  }

  /**
   * Get server logs
   */
  async getServerLogs(serverId, tail = 100) {
    try {
      const server = Server.findById(serverId);
      if (!server) {
        throw new NotFoundError(`Server not found: ${serverId}`);
      }

      if (!server.container_id) {
        throw new ValidationError('Server has no container');
      }

      const logs = await dockerService.getContainerLogs(server.container_id, tail);
      return logs;
    } catch (error) {
      logger.error(`Failed to get server logs: ${error.message}`);
      throw error;
    }
  }

  /**
   * Handle mod/plugin upload or server pack import
   */
  async uploadModOrPack(serverId, file) {
    const server = Server.findById(serverId);
    if (!server) {
      throw new NotFoundError(`Server not found: ${serverId}`);
    }

    if (!file || !file.path) {
      throw new ValidationError('File upload is required');
    }

    const extension = path.extname(file.originalname || '').toLowerCase();
    const volumePath = server.volume_path;

    try {
      if (extension === '.zip') {
        const details = await this.installPackArchive(file.path, volumePath);
        logger.info(`Installed server pack for ${serverId}`);
        return {
          type: 'pack',
          message: 'Server pack imported successfully',
          targetPath: volumePath,
          details
        };
      }

      if (extension === '.jar') {
        const targetFolder = server.type === 'PAPER' ? 'plugins' : 'mods';
        const targetDir = path.join(volumePath, targetFolder);
        fs.mkdirSync(targetDir, { recursive: true });

        const safeName = this.sanitizeFileName(file.originalname);
        const destination = path.join(targetDir, safeName);
        fs.copyFileSync(file.path, destination);
        logger.info(`Uploaded ${safeName} for server ${serverId} to ${targetFolder}`);

        return {
          type: 'mod',
          message: `Uploaded ${safeName} to ${targetFolder}`,
          targetPath: destination
        };
      }

      throw new ValidationError('Only .jar mods or .zip server packs are supported');
    } catch (error) {
      logger.error(`Failed to process upload for server ${serverId}: ${error.message}`);
      throw error;
    } finally {
      fs.unlink(file.path, () => {});
    }
  }

  /**
   * Update server.properties values
   */
  async updateServerSettings(serverId, settings) {
    const server = Server.findById(serverId);
    if (!server) {
      throw new NotFoundError(`Server not found: ${serverId}`);
    }

    const { props, propsPath } = this.getServerProperties(server.volume_path);
    const propertyMap = {
      motd: 'motd',
      maxPlayers: 'max-players',
      difficulty: 'difficulty',
      pvp: 'pvp',
      whitelist: 'white-list',
      allowNether: 'allow-nether',
      hardcore: 'hardcore',
      viewDistance: 'view-distance'
    };

    let changed = false;

    for (const [key, propertyKey] of Object.entries(propertyMap)) {
      if (settings[key] === undefined) continue;
      let value = settings[key];

      switch (key) {
        case 'motd':
          value = this.escapeMotd(value);
          break;
        case 'maxPlayers':
          value = parseInt(value, 10);
          if (Number.isNaN(value)) continue;
          break;
        case 'viewDistance':
          value = parseInt(value, 10);
          if (Number.isNaN(value)) continue;
          break;
        case 'pvp':
        case 'whitelist':
        case 'allowNether':
        case 'hardcore':
          value = value ? 'true' : 'false';
          break;
        case 'difficulty':
          value = String(value).toLowerCase();
          break;
        default:
          value = String(value);
      }

      props[propertyKey] = value;
      changed = true;
    }

    if (!changed) {
      return await this.withConnectionInfo({
        ...server,
        settings: this.getServerSettingsData(server)
      });
    }

    this.writeServerProperties(propsPath, props);
    const updatedSettings = this.getServerSettingsData(server);
    return await this.withConnectionInfo({
      ...server,
      settings: updatedSettings
    });
  }

  /**
   * Update server resource allocation (memory, CPU)
   * Requires server restart to take effect
   */
  async updateServerResources(serverId, resources) {
    const server = Server.findById(serverId);
    if (!server) {
      throw new NotFoundError(`Server not found: ${serverId}`);
    }

    const updates = {};

    if (resources.memory !== undefined) {
      updates.memory = resources.memory;
    }

    if (resources.cpuLimit !== undefined) {
      updates.cpu_limit = resources.cpuLimit;
    }

    if (Object.keys(updates).length === 0) {
      return await this.getServerDetails(serverId);
    }

    // Update in database
    Server.update(serverId, updates);

    // Update docker-compose.yml
    const composePath = path.join(server.volume_path, 'docker-compose.yml');
    if (fs.existsSync(composePath)) {
      try {
        const composeContent = fs.readFileSync(composePath, 'utf8');
        const compose = YAML.parse(composeContent);

        const serviceName = Object.keys(compose.services)[0];
        const service = compose.services[serviceName];

        if (resources.memory) {
          // Update MEMORY environment variable
          if (service.environment) {
            if (Array.isArray(service.environment)) {
              const memIdx = service.environment.findIndex(e =>
                typeof e === 'string' && e.startsWith('MEMORY=')
              );
              if (memIdx >= 0) {
                service.environment[memIdx] = `MEMORY=${resources.memory}`;
              } else {
                service.environment.push(`MEMORY=${resources.memory}`);
              }
            } else {
              service.environment.MEMORY = resources.memory;
            }
          }

          // Update deploy resources
          if (!service.deploy) service.deploy = {};
          if (!service.deploy.resources) service.deploy.resources = {};
          if (!service.deploy.resources.limits) service.deploy.resources.limits = {};

          // Set memory limit slightly higher than heap
          const memMatch = resources.memory.match(/^(\d+)([GM])$/i);
          if (memMatch) {
            const amount = parseInt(memMatch[1]);
            const unit = memMatch[2].toUpperCase();
            // Add 1G buffer for non-heap memory
            const limitAmount = unit === 'G' ? amount + 1 : Math.ceil(amount / 1024) + 1;
            service.deploy.resources.limits.memory = `${limitAmount}G`;
          }
        }

        if (resources.cpuLimit) {
          if (!service.deploy) service.deploy = {};
          if (!service.deploy.resources) service.deploy.resources = {};
          if (!service.deploy.resources.limits) service.deploy.resources.limits = {};
          service.deploy.resources.limits.cpus = String(resources.cpuLimit);
        }

        fs.writeFileSync(composePath, YAML.stringify(compose));
        logger.info(`Updated docker-compose.yml for server ${serverId}`);
      } catch (error) {
        logger.warn(`Failed to update docker-compose.yml: ${error.message}`);
      }
    }

    // Return updated server details
    const updatedServer = await this.getServerDetails(serverId);

    // Add a flag indicating restart is needed
    if (server.status === 'running') {
      updatedServer.restartRequired = true;
    }

    return updatedServer;
  }

  /**
   * Update server icon (server-icon.png)
   */
  async updateServerIcon(serverId, file) {
    const server = Server.findById(serverId);
    if (!server) {
      throw new NotFoundError(`Server not found: ${serverId}`);
    }

    if (!file || !file.path) {
      throw new ValidationError('Icon file is required');
    }

    try {
      const ext = path.extname(file.originalname || '').toLowerCase();
      if (ext !== '.png') {
        throw new ValidationError('Server icon must be a .png file');
      }

      const buffer = fs.readFileSync(file.path);
      let image;
      try {
        image = PNG.sync.read(buffer);
      } catch (error) {
        throw new ValidationError('Invalid PNG file');
      }

      if (image.width !== 64 || image.height !== 64) {
        throw new ValidationError('Server icon must be 64x64 pixels');
      }

      const iconPath = this.getServerIconFilePath(server.volume_path);
      fs.writeFileSync(iconPath, buffer);

      logger.info(`Updated server icon for ${serverId}`);
      return { message: 'Server icon updated successfully' };
    } finally {
      fs.unlink(file.path, () => {});
    }
  }

  /**
   * Get absolute path to server icon (if exists)
   */
  getServerIconPath(serverId) {
    const server = Server.findById(serverId);
    if (!server) {
      throw new NotFoundError(`Server not found: ${serverId}`);
    }

    const iconPath = this.getServerIconFilePath(server.volume_path);
    if (!fs.existsSync(iconPath)) {
      return null;
    }
    return iconPath;
  }

  sanitizeFileName(filename = '') {
    return filename.replace(/[^a-zA-Z0-9._-]/g, '_');
  }

  async withConnectionInfo(server) {
    if (!server) return server;

    let host = getPreferredHost();

    // If server has a container, try to get its IP address
    if (server.container_id) {
      try {
        const containerIP = await dockerService.getContainerIP(server.container_id);
        if (containerIP) {
          // Check if container IP is accessible from local network
          // Docker bridge IPs (172.16-31.x.x) are not accessible externally
          // OrbStack/other setups may use 192.168.x.x or 10.x.x.x which ARE accessible
          const isDockerBridgeIP = this.isDockerBridgeIP(containerIP);

          if (!isDockerBridgeIP) {
            // Container IP is accessible (e.g., OrbStack's 192.168.x.x)
            host = containerIP;
            logger.debug(`Using accessible container IP ${containerIP} for server ${server.id}`);
          } else {
            // Container IP is Docker bridge (172.x.x.x), use host IP instead
            logger.debug(`Container IP ${containerIP} is Docker bridge, using host ${host} for server ${server.id}`);
          }
        }
      } catch (error) {
        logger.warn(`Failed to get container IP for ${server.id}: ${error.message}`);
        // Fall back to global host
      }
    }

    const address = host ? `${host}:${server.port}` : `localhost:${server.port}`;

    return {
      ...server,
      connectionInfo: {
        host: host || 'localhost',
        port: server.port,
        address
      }
    };
  }

  /**
   * Check if an IP address is in the Docker bridge range (172.16-31.x.x)
   * These IPs are not accessible from outside the Docker host
   */
  isDockerBridgeIP(ip) {
    if (!ip) return false;

    const parts = ip.split('.');
    if (parts.length !== 4) return false;

    const first = parseInt(parts[0], 10);
    const second = parseInt(parts[1], 10);

    // Docker bridge networks use 172.16.0.0/12 (172.16.0.0 - 172.31.255.255)
    // Also check for 172.17.0.0/16 which is the default Docker bridge
    if (first === 172 && second >= 16 && second <= 31) {
      return true;
    }

    return false;
  }

  /**
   * Wait for server to be ready
   */
  async waitForServerReady(containerId, maxAttempts = 60) {
    for (let i = 0; i < maxAttempts; i++) {
      const isRunning = await dockerService.isContainerRunning(containerId);

      if (isRunning) {
        // Wait a bit more to ensure the server is fully initialized
        await new Promise(resolve => setTimeout(resolve, 2000));
        return true;
      }

      await new Promise(resolve => setTimeout(resolve, 1000));
    }

    throw new Error('Server failed to start within timeout');
  }

  getServerProperties(volumePath) {
    const propsPath = path.join(volumePath, 'server.properties');
    const props = {};

    if (fs.existsSync(propsPath)) {
      const content = fs.readFileSync(propsPath, 'utf8');
      content.split(/\r?\n/).forEach(line => {
        if (!line || line.startsWith('#')) return;
        const idx = line.indexOf('=');
        if (idx === -1) return;
        const key = line.slice(0, idx).trim();
        const value = line.slice(idx + 1).trim();
        if (key) props[key] = value;
      });
    }

    return { props, propsPath };
  }

  writeServerProperties(propsPath, props) {
    fs.mkdirSync(path.dirname(propsPath), { recursive: true });
    const lines = [
      '# Minecraft server properties',
      `# Updated ${new Date().toISOString()}`
    ];

    Object.keys(props)
      .sort()
      .forEach((key) => {
        lines.push(`${key}=${props[key]}`);
      });

    fs.writeFileSync(propsPath, `${lines.join('\n')}\n`, 'utf8');
  }

  getServerSettingsData(server) {
    if (!server) return {};
    const { props } = this.getServerProperties(server.volume_path);

    const parseBool = (value, fallback = false) => {
      if (value === undefined) return fallback;
      return String(value).toLowerCase() === 'true';
    };

    const toInt = (value, fallback) => {
      if (value === undefined) return fallback;
      const num = parseInt(value, 10);
      return Number.isNaN(num) ? fallback : num;
    };

    return {
      motd: this.unescapeMotd(props['motd'] || ''),
      maxPlayers: toInt(props['max-players'], 20),
      difficulty: props['difficulty'] || 'easy',
      pvp: parseBool(props['pvp'], true),
      whitelist: parseBool(props['white-list'], false),
      allowNether: parseBool(props['allow-nether'], true),
      hardcore: parseBool(props['hardcore'], false),
      viewDistance: toInt(props['view-distance'], 10)
    };
  }

  getServerIconFilePath(volumePath) {
    return path.join(volumePath, 'server-icon.png');
  }

  escapeMotd(value = '') {
    return String(value).replace(/\r?\n/g, '\\n');
  }

  unescapeMotd(value = '') {
    return value.replace(/\\n/g, '\n');
  }

  /**
   * List files within server's volume
   */
  async listServerFiles(serverId, targetPath = '') {
    const server = Server.findById(serverId);
    if (!server) {
      throw new NotFoundError(`Server not found: ${serverId}`);
    }

    const resolved = this.resolveServerPath(server.volume_path, targetPath);
    if (!fs.existsSync(resolved)) {
      throw new NotFoundError('Path does not exist');
    }

    const stats = fs.statSync(resolved);
    if (!stats.isDirectory()) {
      throw new ValidationError('Path must be a directory');
    }

    const entries = fs.readdirSync(resolved, { withFileTypes: true })
      .map((dirent) => {
        const fullPath = path.join(resolved, dirent.name);
        const stat = fs.statSync(fullPath);
        return {
          name: dirent.name,
          type: dirent.isDirectory() ? 'directory' : 'file',
          size: dirent.isDirectory() ? null : stat.size,
          modified: stat.mtimeMs,
          path: path.relative(server.volume_path, fullPath)
        };
      })
      .sort((a, b) => {
        if (a.type === b.type) {
          return a.name.localeCompare(b.name);
        }
        return a.type === 'directory' ? -1 : 1;
      });

    const relativePath = path.relative(server.volume_path, resolved);

    return {
      path: relativePath || '',
      entries
    };
  }

  /**
   * Upload arbitrary file to server volume
   */
  async uploadServerFile(serverId, destPath, file) {
    const server = Server.findById(serverId);
    if (!server) {
      throw new NotFoundError(`Server not found: ${serverId}`);
    }

    if (!file || !file.path) {
      throw new ValidationError('File upload is required');
    }

    const destinationDir = this.resolveServerPath(server.volume_path, destPath || '');

    const stats = fs.existsSync(destinationDir) ? fs.statSync(destinationDir) : null;
    if (stats && !stats.isDirectory()) {
      throw new ValidationError('Destination path must be a directory');
    }

    fs.mkdirSync(destinationDir, { recursive: true });
    const safeName = this.sanitizeFileName(file.originalname);
    const destination = path.join(destinationDir, safeName);

    fs.copyFileSync(file.path, destination);
    fs.unlink(file.path, () => {});

    logger.info(`Uploaded file ${safeName} for server ${serverId}`);
    return {
      message: 'File uploaded successfully',
      path: path.relative(server.volume_path, destination)
    };
  }

  getFileDownloadPath(serverId, targetPath = '') {
    const server = Server.findById(serverId);
    if (!server) {
      throw new NotFoundError(`Server not found: ${serverId}`);
    }

    const resolved = this.resolveServerPath(server.volume_path, targetPath);
    if (!fs.existsSync(resolved)) {
      throw new NotFoundError('File not found');
    }

    const stat = fs.statSync(resolved);
    if (!stat.isFile()) {
      throw new ValidationError('Only files can be downloaded');
    }

    return {
      absolutePath: resolved,
      filename: path.basename(resolved)
    };
  }

  resolveServerPath(volumePath, targetPath = '') {
    const normalized = path.normalize(targetPath || '');
    const joined = path.normalize(path.join(volumePath, normalized));
    if (!joined.startsWith(volumePath)) {
      throw new ValidationError('Path traversal is not allowed');
    }
    return joined;
  }

  normalizeServerType(type) {
    const normalized = String(type || 'PAPER').toUpperCase();
    if (!this.serverTypes.includes(normalized)) {
      throw new ValidationError(`Unsupported server type: ${type}`);
    }
    return normalized;
  }

  getModpackDir(type) {
    const normalized = this.normalizeServerType(type);
    return path.join(this.modpacksBasePath, normalized.toLowerCase());
  }

  listSavedModpacks(type) {
    const dir = this.getModpackDir(type);
    if (!fs.existsSync(dir)) return [];
    return fs.readdirSync(dir)
      .filter((name) => name.toLowerCase().endsWith('.zip'))
      .map((filename) => this.buildModpackSummary(type, filename))
      .sort((a, b) => {
        const toTimestamp = (value) => {
          if (!value) return 0;
          const ts = new Date(value).getTime();
          return Number.isFinite(ts) ? ts : 0;
        };
        return toTimestamp(b.importedAt) - toTimestamp(a.importedAt);
      });
  }

  listAllSavedModpacks() {
    const packs = this.serverTypes.flatMap((type) => this.listSavedModpacks(type));
    return packs.sort((a, b) => {
      const toTimestamp = (value) => {
        if (!value) return 0;
        const ts = new Date(value).getTime();
        return Number.isFinite(ts) ? ts : 0;
      };
      return toTimestamp(b.importedAt) - toTimestamp(a.importedAt);
    });
  }

  saveModpackFile(type, file) {
    const dir = this.getModpackDir(type);
    const ext = path.extname(file.originalname || '').toLowerCase();
    if (ext !== '.zip') {
      throw new ValidationError('Only .zip modpack files are supported');
    }
    const safeName = this.sanitizeFileName(file.originalname);
    const destination = path.join(dir, safeName);
    fs.copyFileSync(file.path, destination);
    const metadataPath = path.join(dir, `${path.basename(safeName, ext)}.json`);
    try {
      const extractedMetadata = modpackImportService.extractZipMetadata(file.path);
      const metadata = {
        ...extractedMetadata,
        source: 'upload',
        originalName: file.originalname,
        name: extractedMetadata?.name
          || extractedMetadata?.manifest?.name
          || path.basename(safeName, ext),
        importedAt: new Date().toISOString(),
        serverType: this.normalizeServerType(type),
        fileName: safeName
      };
      fs.writeFileSync(metadataPath, JSON.stringify(metadata, null, 2));
    } catch (error) {
      logger.warn(`Unable to extract metadata for uploaded modpack ${safeName}: ${error.message}`);
    }
    return this.buildModpackSummary(type, safeName);
  }

  deleteSavedModpack(type, filename) {
    if (!filename) {
      throw new ValidationError('Filename is required');
    }

    const dir = this.getModpackDir(type);
    const safeName = this.sanitizeFileName(filename);
    const fullPath = path.join(dir, safeName);

    if (!fs.existsSync(fullPath)) {
      throw new NotFoundError(`Modpack not found: ${filename}`);
    }

    fs.unlinkSync(fullPath);

    const metadataPath = path.join(dir, `${path.basename(safeName, path.extname(safeName))}.json`);
    if (fs.existsSync(metadataPath)) {
      fs.unlinkSync(metadataPath);
    }

    logger.info(`Deleted modpack ${safeName} from ${type}`);

    return {
      filename: safeName
    };
  }

  getSavedModpackZip(type, filename) {
    if (!filename) {
      throw new ValidationError('Modpack selection is required');
    }
    const dir = this.getModpackDir(type);
    const safeName = this.sanitizeFileName(filename);
    const fullPath = path.join(dir, safeName);
    if (!fs.existsSync(fullPath)) {
      throw new NotFoundError(`Modpack not found: ${filename}`);
    }
    return fullPath;
  }

  async installSavedModpack(type, filename, volumePath) {
    const zipPath = this.getSavedModpackZip(type, filename);
    return this.installPackArchive(zipPath, volumePath);
  }

  async applyModpackToServer(serverId, modpackFilename) {
    const server = Server.findById(serverId);
    if (!server) {
      throw new NotFoundError(`Server not found: ${serverId}`);
    }

    // Server should be stopped for modpack installation
    if (server.status === 'running') {
      throw new ValidationError('Server must be stopped before applying a modpack');
    }

    logger.info(`Applying modpack ${modpackFilename} to server ${serverId}`);

    try {
      // Install the modpack to the server's volume
      const result = await this.installSavedModpack(server.type, modpackFilename, server.volume_path);

      logger.info(`Successfully applied modpack ${modpackFilename} to server ${serverId}`);

      return {
        message: 'Modpack applied successfully',
        modpack: modpackFilename,
        ...result
      };
    } catch (error) {
      logger.error(`Failed to apply modpack ${modpackFilename} to server ${serverId}: ${error.message}`);
      throw error;
    }
  }

  buildModpackSummary(type, filename) {
    const metadata = this.getModpackMetadata(type, filename);
    const baseName = path.basename(filename, path.extname(filename));
    const gameVersions = this.extractGameVersionsFromMetadata(metadata);
    const normalizedType = this.normalizeServerType(type);

    return {
      name: metadata?.name || metadata?.manifest?.name || baseName,
      filename,
      version: metadata?.version || metadata?.manifest?.version || metadata?.modrinthIndex?.versionId,
      description: metadata?.description,
      importedAt: metadata?.importedAt || null,
      serverType: metadata?.serverType || normalizedType,
      gameVersions,
      loaders: metadata?.loaders
        || metadata?.manifest?.modLoaders?.map((loader) => loader.id || loader)
        || (metadata?.modrinthIndex?.dependencies?.loader ? [metadata.modrinthIndex.dependencies.loader] : undefined)
    };
  }

  getModpackMetadata(type, filename) {
    try {
      const dir = this.getModpackDir(type);
      const baseName = path.basename(filename, path.extname(filename));
      const metadataPath = path.join(dir, `${baseName}.json`);
      if (!fs.existsSync(metadataPath)) {
        return null;
      }
      const raw = fs.readFileSync(metadataPath, 'utf8');
      return JSON.parse(raw);
    } catch (error) {
      logger.warn(`Failed to read metadata for modpack ${filename}: ${error.message}`);
      return null;
    }
  }

  extractGameVersionsFromMetadata(metadata) {
    if (!metadata) return [];
    const versions = new Set();
    if (Array.isArray(metadata.gameVersions)) {
      metadata.gameVersions.forEach((version) => {
        if (version) versions.add(String(version));
      });
    }
    if (metadata.manifest?.minecraftVersion) {
      versions.add(String(metadata.manifest.minecraftVersion));
    }
    if (metadata.modrinthIndex?.gameVersion) {
      versions.add(String(metadata.modrinthIndex.gameVersion));
    }
    if (metadata.modrinthIndex?.dependencies?.minecraft) {
      versions.add(String(metadata.modrinthIndex.dependencies.minecraft));
    }
    if (metadata.modrinthIndex?.dependencies?.minecraftVersion) {
      versions.add(String(metadata.modrinthIndex.dependencies.minecraftVersion));
    }
    return Array.from(versions).sort((a, b) => this.compareMinecraftVersions(b, a));
  }

  compareMinecraftVersions(a, b) {
    if (a === b) return 0;
    const parseParts = (value) => String(value)
      .split('.')
      .map((part) => {
        const numeric = parseInt(part.replace(/[^0-9]/g, ''), 10);
        return Number.isNaN(numeric) ? null : numeric;
      });

    const aParts = parseParts(a);
    const bParts = parseParts(b);
    const length = Math.max(aParts.length, bParts.length);

    for (let i = 0; i < length; i++) {
      const aVal = aParts[i];
      const bVal = bParts[i];
      if (aVal === null || bVal === null) {
        continue;
      }
      if (aVal !== bVal) {
        return aVal - bVal;
      }
    }

    // Fallback to locale compare if numeric parts were inconclusive
    return String(a).localeCompare(String(b), undefined, { numeric: true, sensitivity: 'base' });
  }

  async installPackArchive(zipPath, volumePath) {
    const tempDir = fs.mkdtempSync(path.join(os.tmpdir(), 'mc-pack-'));
    try {
      logger.info(`Extracting modpack from ${zipPath} to ${tempDir}`);
      const zip = new AdmZip(zipPath);
      zip.extractAllTo(tempDir, true);
      const packRoot = this.detectPackRoot(tempDir);
      logger.info(`Detected pack root: ${packRoot}`);
      logger.info(`Installing to volume path: ${volumePath}`);
      return this.installPackFromDirectory(packRoot, volumePath);
    } finally {
      fs.rmSync(tempDir, { recursive: true, force: true });
    }
  }

  detectPackRoot(extractedDir) {
    const entries = fs.readdirSync(extractedDir).filter((name) => name !== '__MACOSX');
    if (entries.length === 1) {
      const single = path.join(extractedDir, entries[0]);
      if (fs.statSync(single).isDirectory()) {
        return single;
      }
    }
    return extractedDir;
  }

  async installPackFromDirectory(packRoot, volumePath) {
    const summary = [];
    logger.info(`Scanning pack root for directories: ${packRoot}`);
    const availableDirs = fs.readdirSync(packRoot);
    logger.info(`Available items in pack root: ${availableDirs.join(', ')}`);

    summary.push(...this.copyPackContents(packRoot, volumePath, 'pack'));

    const overridesDir = path.join(packRoot, 'overrides');
    if (fs.existsSync(overridesDir) && fs.statSync(overridesDir).isDirectory()) {
      logger.info(`Detected overrides directory at ${overridesDir}`);
      summary.push(...this.copyPackContents(overridesDir, volumePath, 'overrides'));
    }

    const modrinthIndexPath = path.join(packRoot, 'modrinth.index.json');
    const modrinthIndex = this.safeReadJson(modrinthIndexPath);
    if (modrinthIndex) {
      logger.info('Installing files referenced in modrinth.index.json');
      summary.push(...await this.installModrinthFiles(modrinthIndex, volumePath));
    }

    logger.info(`Installation summary: ${summary.join(', ')}`);
    return summary;
  }

  copyPackContents(sourceRoot, volumePath, sourceLabel = 'pack') {
    const summary = [];
    const directories = [
      'config',
      'mods',
      'libraries',
      'versions',
      'kubejs',
      'scripts',
      'defaultconfigs',
      'resources',
      'resourcepacks',
      'datapacks',
      'shaderpacks'
    ];

    directories.forEach((dirName) => {
      const source = path.join(sourceRoot, dirName);
      if (fs.existsSync(source) && fs.statSync(source).isDirectory()) {
        const destination = path.join(volumePath, dirName);
        const fileCount = fs.readdirSync(source).length;
        logger.info(`Copying ${sourceLabel}:${dirName}/ (${fileCount} items) from ${source} to ${destination}`);
        fs.rmSync(destination, { recursive: true, force: true });
        fs.mkdirSync(path.dirname(destination), { recursive: true });
        fs.cpSync(source, destination, { recursive: true });
        summary.push(`Copied ${sourceLabel}:${dirName}/ (${fileCount} items)`);
      } else {
        logger.debug(`Directory ${dirName}/ not found in ${sourceLabel}`);
      }
    });

    const rootEntries = fs.readdirSync(sourceRoot);
    rootEntries.forEach((name) => {
      if (name === 'overrides') return;
      const source = path.join(sourceRoot, name);
      const stat = fs.statSync(source);
      if (stat.isFile()) {
        const destination = path.join(volumePath, name);
        logger.info(`Copying ${sourceLabel} root file ${name} to ${destination}`);
        fs.copyFileSync(source, destination);
        summary.push(`Placed ${sourceLabel}:${name}`);
      }
    });

    return summary;
  }

  safeReadJson(filePath) {
    try {
      if (!fs.existsSync(filePath)) {
        return null;
      }
      const contents = fs.readFileSync(filePath, 'utf8');
      return JSON.parse(contents);
    } catch (error) {
      logger.warn(`Failed to parse JSON file at ${filePath}: ${error.message}`);
      return null;
    }
  }

  async installModrinthFiles(indexData, volumePath) {
    if (!indexData || !Array.isArray(indexData.files)) {
      logger.warn('Modrinth index found but no files array present, skipping downloads');
      return [];
    }

    const summary = [];
    for (const fileEntry of indexData.files) {
      const relativePath = fileEntry.path;
      if (!relativePath) {
        logger.warn('Encountered Modrinth file entry without a path, skipping');
        continue;
      }

      const serverEnv = fileEntry.env?.server || 'required';
      if (serverEnv === 'unsupported') {
        logger.info(`Skipping ${relativePath} because it is unsupported on servers`);
        continue;
      }
      if (serverEnv === 'optional' && fileEntry.option?.default === false) {
        logger.info(`Skipping optional ${relativePath} because it is disabled by default`);
        continue;
      }

      const downloads = Array.isArray(fileEntry.downloads) ? fileEntry.downloads : [];
      if (downloads.length === 0) {
        logger.warn(`No download URLs provided for ${relativePath}, skipping`);
        continue;
      }

      const destination = this.resolveServerPath(volumePath, relativePath);
      fs.mkdirSync(path.dirname(destination), { recursive: true });

      await this.downloadFileWithFallback(downloads, destination);
      this.verifyFileHash(destination, fileEntry.hashes, relativePath);

      summary.push(`Downloaded ${relativePath}`);
    }

    return summary;
  }

  async downloadFileWithFallback(urls, destination) {
    let lastError = null;
    for (const url of urls) {
      try {
        logger.info(`Downloading ${url} to ${destination}`);
        const response = await axios({
          method: 'GET',
          url,
          responseType: 'stream',
          timeout: 300000,
          headers: {
            'User-Agent': 'Minecraft-Server-Manager/1.0'
          }
        });

        await new Promise((resolve, reject) => {
          const writer = fs.createWriteStream(destination);
          response.data.pipe(writer);
          writer.on('finish', resolve);
          writer.on('error', reject);
        });
        return;
      } catch (error) {
        lastError = error;
        logger.warn(`Failed to download ${url}: ${error.message}`);
        fs.rmSync(destination, { force: true });
      }
    }

    throw new Error(`Failed to download file after ${urls.length} attempts: ${lastError?.message || 'unknown error'}`);
  }

  verifyFileHash(filePath, expectedHashes = {}, relativePath) {
    if (!expectedHashes || typeof expectedHashes !== 'object') {
      return;
    }

    const supportedAlgorithms = ['sha512', 'sha256', 'sha1', 'md5'];
    for (const algorithm of supportedAlgorithms) {
      if (expectedHashes[algorithm]) {
        const actualHash = crypto
          .createHash(algorithm)
          .update(fs.readFileSync(filePath))
          .digest('hex');
        if (actualHash.toLowerCase() !== expectedHashes[algorithm].toLowerCase()) {
          throw new ValidationError(`Checksum mismatch for ${relativePath} (${algorithm})`);
        }
        logger.debug(`Verified ${relativePath} using ${algorithm}`);
        return;
      }
    }

    logger.warn(`No supported hashes provided for ${relativePath}, skipping verification`);
  }
}

// Export singleton instance
export default new ServerService();
